\documentclass[a4paper,12pt]{report}

\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{cleveref}

\title{Embedded Systems and Internet-of-Things \\ - \\ Third Assignment}
\author{Kimi Osti}
\date{\today}

\begin{document}
	
	\maketitle
	\tableofcontents
	
	\chapter{System Requirements}
	The system is a smart IoT-based temperature monitor. In particular, it measures a closed environment's temperature at any given time, and controls a window connected to a motor to properly ventilate the room in case of critical temperatures. It also implements a manual mode, which can be activated directly on the \textit{Window Controller}, or via a web-based \textit{Operator Dashboard}, that allows an operator to control the window opening angle, in place or remotely.
	\newline The system consists of four sub-systems.
	\section{Temperature Monitor}
	The \textit{Temperature Monitor} periodically samples the room's temperature, and communicates it to the \textit{Control Unit}. The recorded values determine the system's overall state, which in turn determines the sample frequency: higher temperatures mean critical states, which demand more frequent temperature sampling. It communicates with the \textit{Control Unit} via the \textit{MQTT} protocol, and includes two LEDs signaling whether the connection is properly established: a green one signaling that the sub-system is online, and a red one signaling that the connection was lost.
	\section{Window Controller}
	The \textit{Window Controller} is the sub-system that physically controls the window opening level via a servo motor. It also exposes a little operator dashboard, consisting of a button to switch between automatic and manual mode, a potentiometer to control the window opening level in-place and a screen showing the current opening level, the operating mode and, when in manual mode, the current temperature value.
	\newline All communication with the \textit{Control Unit} is achieved via \textit{Serial Line}.
	\section{Operator Dashboard}
	The \textit{Operator Dashboard} is a web-based application that allows the operator to work remotely on the system. It shows a graph representing all the measurements recorded by the system in the last minute, sided by a statistic showing the average, minimum and maximum value in the same interval of time. It also shows the current state of the system and the window opening percentage. It allows the operator to perform all the actions provided by the \textit{Window Controller}, which are to switch operative mode and to control the opening level of the window. In addition to that, it allows an operator to restore the \textit{normal} state, after an alarm triggered by the temperature being critical for a certain amount of time.
	\newline It communicates with the \textit{Control Unit} via \textit{HTTP}.
	\section{Control Unit}
	The \textit{Control Unit} is the core of the entire system. It's mainly responsible of keeping track of the history of the measurements recorded by the \textit{Temperature Monitor}, and to ensure consistency and proper actuation of the actions demanded by in-place operators via the \textit{Window Controller} and remote ones via the \textit{Operator Dashboard}. It also demands a certain sampling frequency to the \textit{Temperature Monitor}, to ensure that the system state is kept well under control, especially when the temperature reaches critical levels.
	
	\chapter{System Architecture}
	The system architecture can be analyzed splitting the system in the four main sub-systems highlighted previously.
	\section{Temperature Monitor}
	This subsystem's main feature is sampling the room's temperature with a given frequency. It's also responsible for sending the collected data to the \textit{Control Unit}, so it must include a component handling the subsystem connectivity to the back-end.
	\newline Its behavior can be modeled in four Tasks running in parallel, that can all be modeled as Finite State Machines. In particular, all Tasks can be modeled in a synchronous way, running at a fixed period that dictates their steps.
		\subsection{Temperature Measuring Task}
		The central Task is the one responsible of actually measuring the temperature. Its main feature is the variable execution period, here depicted with the \textit{freq} parameter. In particular, it is dictated by the \textit{Control Unit} in response to the measured temperature.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/temp-monitor/temp-measuring-fsm.png}
			\caption{FSM modeling the temperature measuring task behavior}
			\label{img:temp-monitor/temp-measuring-fsm}
		\end{figure}
		It is clearly depicted how state transitions in automatic mode are determined by the last measured temperature value. But in reality, all state transitions are demanded by the \textit{Control Unit}, which ensures consistency handling all inputs from all sub-components.
		\newline Also, it is clearly modeled to be network-agnostic. Indeed, this Task is supposed to measure the room's temperature at all times, and data sharing is delegated to a different Task.
		\subsection{Connection Monitoring Task}
		This Task is the one responsible of checking whether the component is still connected to the \textit{Control Unit}, and when it's not, to try and reconnect. It works on two layers: the first one checks whether the system is online, and another one, when connected to the Internet, checks whether the \textit{MQTT} subscription is properly established.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/temp-monitor/connection-monitoring-fsm.png}
			\caption{FSM modeling the connection monitoring task behavior}
			\label{img:temp-monitor/connection-monitoring-fsm}
		\end{figure}
		\subsection{Communication Task}
		This Task is responsible of communicating with the \textit{Control Unit} exploiting the \textit{MQTT} connection set up by the \textit{Connection Monitoring Task}. It ensures that data is properly collected, assembled to form a message and sent to the \textit{Control Unit}. On the other hand, it's also responsible of receiving the response messages published by the \textit{Control Unit}, which dictates the \textit{Temperature Measuring Task} state, and consequently its sampling frequency.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/temp-monitor/communication-fsm.png}
			\caption{FSM modeling the communication task behavior}
			\label{img:temp-monitor/communication-fsm}
		\end{figure}
		It's here clear how this task too is network agnostic: simply, when there is no connection or no active \textit{MQTT} subscription no messages are received - and the system therefore never goes to the \textit{Receiving} state - and the ones that are supposed to be sent are actually lost.
		\newline Additionally, it's noticeable how this Task has at least a part that runs asynchronously: whenever a message is received, regardless of how much time has elapsed since the last one, a response is triggered in this Task. But this is not an issue since the Task is only meant to receive messages in response to the ones it sends: so the message receiving can be considered as a part of the single step of a synchronous Finite State Machine running at the same variable period of the \textit{Temperature Measuring Task}.
		\subsection{LED Task}
		This Task's main responsibility is to represent to the operator whether the sub-system is online.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/temp-monitor/led-fsm.png}
			\caption{FSM modeling the LED task behavior}
			\label{img:temp-monitor/led-fsm}
		\end{figure}
		In this scheme, it's obvious how this Task's state depends directly on the state of the \textit{Connection Monitoring Task}. In particular, the LED is shown as green only when the device is connected to the Internet and the \textit{MQTT} subscription is properly established.
		\subsection{Shared Data}
		In this sub-system, shared data is used to ensure consistency in the behavior of different Tasks. In particular, it's used to demand state transitions to Tasks that depend on other Tasks' state.
		\newline To achieve inter-Task communication, all Tasks store a reference to a shared object. Its main concern is thread-safety: all accesses to shared data have to be implemented in such a way to avoid dirty reads, inconsistencies or - even worse in a real-time sensing system - deadlocks.
	\section{Window Controller}
	This component's main responsibility is to actuate the window opening level, based on the values sent by the \textit{Control Unit} via \textit{Serial Line}. Furthermore, it exposes a small operating dashboard to switch between operative modes (automatic or manual) and to control the window's opening level, if in manual mode. Its behavior can be modeled with a task-based architecture, giving each task a small set of features to handle. Each one of these tasks can be modeled as a synchronous Finite State Machine, timed by a central scheduler whose only responsibility is to keep everything running at the right pace.
		\subsection{Window Controlling Task}
		This Task is the one actually responsible of actuating the window opening level. Its only job is to set the window opening percentage as demanded by the \textit{Control Unit}, regardless of the overall system state.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/window-controller/window-controlling-fsm.png}
			\caption{FSM modeling the window controlling task behavior}
			\label{img:window-controller/window-controlling-fsm}
		\end{figure}
		It's obvious in this representation how this Finite State Machine actually only has one state, and repeatedly sets the window's opening level based on the system's demands.
		\subsection{Operator Input Task}
		This Task is responsible of collecting user input. Its main concern is the choice of the period: it must be long enough to prevent faulty reads depending especially on the button's bouncing effects, but it also should be short enough to avoid losing operator inputs.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/window-controller/operator-input-fsm.png}
			\caption{FSM modeling the operator input task behavior}
			\label{img:window-controller/operator-input-fsm}
		\end{figure}
		In this scheme it's underlined for clarity how operator input via the potentiometer is only accepted in \textit{Manual} mode. For better consistency though, data isn't directly sent to the \textit{Window Controlling Task}, but rather a decoupling level is inserted between the two Tasks, sending all data to the \textit{Control Unit}, where state handling responsibilities are centralized.
		\subsection{Operator Output Task}
		This task is responsible of showing the operator some information about the system's current state. Obviously, for the reasons described above, the system's state is received from the \textit{Control Unit}, delegating it all data consistency issues.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/window-controller/operator-output-fsm.png}
			\caption{FSM modeling the Operator Output Task}
			\label{img:window-controller/operator-output-fsm}
		\end{figure}
		In this scheme, it's depicted how this Task is showing different information according to the state of the system. On the other hand, state transitions are not handled in any way by this Task, and the \textit{modeSwitch} depends on some input received by the \textit{Control Unit}.
		\subsection{Communication Task}
		This Task is responsible of communicating via the \textit{Serial Line} with the \textit{Control Unit}. It's a core feature of this sub-system, since correct communication ensures data (and more importantly behavior) consistency when translating computation into actuation.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/window-controller/communication-fsm.png}
			\caption{FSM modeling the communication task behavior}
			\label{img:window-controller/communication-fsm}
		\end{figure}
		Each period this Task (which is clearly depicted as state-agnostic) sends a message containing this sub-system's demands for the \textit{Control Unit} - in particular whether the mode was switched and the last input opening level - and checks for a response's availability. Whenever an incoming message is completely received, it is processed by this Task, which updates the current state of the system as demanded by the \textit{Control Unit}.
		\subsection{Shared Data}
		In this sub-system, shared data between Tasks is crucial for behavior consistency. For this purpose, two objects are exploited: a \textit{Dirty State Tracker} which saves the current sub-system input requests, and a \textit{State Tracker} which saves the last \textit{Control Unit} demands, considered to be the only source of valid data in the system.
		\begin{figure}[H]
			\centering{}
			\includegraphics[scale=0.5]{img/window-controller/shared-data.png}
			\caption{Dependencies between tasks and shared data}
			\label{img:window-controller/shared-data}
		\end{figure}
		The two state tracking objects have to be \textit{Singletons}, since they store the only valid sub-system state.
	\section{Operator Dashboard}
	The \textit{Operator Dashboard} is implemented as a very simple web-based application. It consists of just one page, with an area where the measurement chart is shown (together with all related statistics) and another area where buttons can be used to input some actions to the system.
	\newline It communicates with the \textit{Control Unit} via \textit{HTTP}, and it runs some client-side computation on two layers. The first one simply consists of all the \textit{HTTP requests} that happen when the user submits some input, while the second one (with more of an \textit{AJAX}-oriented and more modern approach to web applications) allows the client to periodically retrieve data in the background to keep the chart updated with all the most recent measures, without requiring user operations.
	\section{Control Unit}
	This sub-system is the core of the application. It exchanges data with all other sub-systems, and ensures data consistency storing internally all relevant values. Its main responsibility is to bridge between protocols to coordinate all system components' behavior, keeping it consistent.
	\newline This sub-system itself is made out of various components.
	\begin{figure}[H]
		\centering{}
		\includegraphics[scale=0.5]{img/control-unit/architecture.png}
		\caption{UML class diagram showing the architecture scheme for the Control Unit sub-components}
		\label{img:control-unit/architecture}
	\end{figure}
	In this scheme, the \textit{CentralController} is the one responsible of ensuring proper data consistency, and it cooperates with all the other sub-components to properly communicate with all other sub-systems. The main concern when implementing this sub-system is to ensure that data is properly stored and can be safely accessed, preventing race conditions and other concurrency issues.
	
	\chapter{Implementing Solutions}
	\section{Temperature Monitor}
	\begin{figure}[H]
		\centering{}
		\includegraphics[scale=0.75]{img/temp-monitor/circuit.png}
		\caption{Detailed circuit for the temperature monitor sub-system}
		\label{img:temp-monitor/circuit}
	\end{figure}
	In this scheme is depicted the detailed circuit for the \textit{Temperature Monitor}, deployed on an \textit{ESP32 System-on-a-Chip} and programmed relying on the \textit{Wiring} framework.
	\newline The \textit{ESP32} holds enough program memory to host a lightweight Operating System, which means that there is no need to implement a scheduler from scratch. For this project, \href{https://www.freertos.org/}{\textit{the FreeRTOS Operating System}} was used, allowing to run Tasks in parallel on both cores of the \textit{ESP32} board.
	\newline Specifically, both network-related tasks are pinned to \textit{Core 0}. This implementation was chosen because, using \textit{FreeRTOS} on \textit{ESP32}, the \textit{event Task} is automatically pinned to \textit{Core 0}, and so all WiFi events are dispatched on that core. On the other hand, the \textit{LED Task} and the \textit{Temperature Measuring Task} are left unpinned, delegating to the OS the responsibility to balance load, using hardware resources as efficiently as possible.
	\subsection{Libraries and External Dependencies}
	For what concerns communication, since the system relies on the \textit{MQTT} protocol, the \href{https://pubsubclient.knolleary.net/}{\textit{PubSubClient library}} was used. This particular library allows the programmer to subscribe to specific topics from a specific broker, without having to deal with protocol-specific low level aspects. The message content is represented in JSON format. In particular, each period this sub-system sends the \textit{Control Unit} the last temperature measure, and it expects to receive messages containing the demanded sampling frequency.
	\section{Window Controller}
	\begin{figure}[H]
		\centering{}
		\includegraphics[width=\textwidth]{img/window-controller/circuit.png}
		\caption{Detailed circuit for the window controller sub-system}
		\label{img:window-controller/circuit}
	\end{figure}
	In this scheme, available at \href{https://www.tinkercad.com/things/2nadVXk0wQ5-esiot-assignment-03-arduino?sharecode=t4LayAw_Rc1SNLqdSHt3uK_EuT6TttEPHQjHAwEp-Zc}{\textit{this link}}, is depicted the detailed circuit for the \textit{Window Controller}, deployed on an \textit{Arduino UNO Board} and also programmed relying on the \textit{Wiring} framework.
	\newline Working on an \textit{Arduino UNO Board} relieves the programmer from all kind of concurrency-related concerns (which would be crucial in this environment, where all tasks work on the same two shared \textit{Singletons}) since the Board is equipped with a single core micro-controller.
	\newline On the other hand, one of the main concerns is to implement our own scheduler, since Arduino UNO doesn't support any kind of Operating System. This can be easily achieved implementing a \textit{Cooperative Round Robin Scheduler}, given that all Tasks have finite - and relatively short - execution routines. The only things to care for are the scheduler period and the implicit Task priorities that this kind of scheduler defines, since it runs some Tasks before others.
	\newline For what concerns the scheduler period, the two mutually exclusive aspects to keep in mind are \textit{deadlines} and \textit{event loss}: the ideal period would be short enough to never lose events, and long enough to allow all Tasks to execute in its duration, so to avoid failing deadlines. The ideal choice for the scheduler length would be the Tasks periods least common divisor, which is in my case 100ms, long enough to allow for all tasks to execute and short enough to miss no events, since the \textit{Operator Input Task} has a period of 100ms itself.
	\newline For what concerns implicit Task priorities, it's not really an issue in this sub-system. This because data is always valid, since the only valid source of data is considered to be the \textit{Control Unit} (and therefore the reads performed by the \textit{Communication Task} on the \textit{Serial Line}), and because possible delays introduces by Task execution order are in the magnitude of tens of milliseconds, not relevant since the unit interacts with human operators and controls a servo motor, which has longer operating times.
	\newline Another aspect to deal with is data format to be sent on the \textit{Serial Line}. Messages on the Serial Line are meant to be as light as possible, to lower as much as possible transmission times and parsing times in a resource-constrained environment such as the Arduino UNO Board.
	\newline \textit{Outgoing} messages have a fixed length of 5 characters: the first is a letter (t or f), and represents whether the operator has requested a mode switch pressing the tactile button, then a space as a separator and the percentage represented as a three digit number. For example, a message requesting a mode switch and inputting an 80\% opening level would be
	\begin{verbatim}
		t 080
	\end{verbatim}
	\textit{Incoming} messages also have a fixed length of 14 characters, and are made of three parts. The overall structure is
	\begin{verbatim}
		Txx.xx Mx Oxxx
	\end{verbatim}
	where the first part represents the temperature truncated to the second decimal digit, the second one represents whether the system is currently in manual mode, and the third one represents the last valid opening level as recorded on the \textit{Control Unit}.
		\subsection{Libraries and External Dependencies}
		For the scheduler timing purposes, I relied on this \href{https://github.com/sstaub/Timer}{\textit{Timer library}} to avoid relying on system timer interrupts.
		\newline The LCD Screen, which works with the \textit{I\textsuperscript{2}C} protocol, is controlled by the \href{https://docs.arduino.cc/libraries/liquidcrystal-i2c/}{\textit{LiquidCrystal I\textsuperscript{2}C library}} to avoid having to handle all the low-level aspects of that communication protocol.
		\newline The servo motor is controlled via the \href{https://github.com/nabontra/ServoTimer2}{\textit{ServoTimer2 library}}, which exploits one of the 8-bit system timers leaving the only 16-bit timer (Timer 1) free for other purposes.
	\section{Operator Dashboard}
	This sub-system is a web-based application that allows an operator to inspect the current state of the system, and to perform some simple actions on it. It's interface is realized with \textit{HTML} and \textit{CSS}, and client-side computation is programmed in \textit{JavaScript}.
	\newline In particular, \textit{HTML} and \textit{CSS} structure the page, and are retrieved when a new window is opened (or whenever there is a manual refresh of the page), while \textit{JavaScript} computation is mainly used to handle automatic data retrieval in the background, in order to keep the measurement chart updated. It's also used to handle button input, apart from the opening level requests, that are handled thanks to a form structured in \textit{HTML}.
	\subsection{Libraries and External Dependencies}
	To draw the measurements history, the \href{https://www.chartjs.org/}{\textit{Chart.js library}} was used.
	\section{Control Unit}
	The \textit{Control Unit} is the core sub-system, that keeps track of the whole system's state in a consistent way. It's on its own divided in a few parts.
		\subsection{Database}
		The first component is a rather trivial, yet essential, database implemented in \textit{mySQL}. It's made out of only one table, but it allows the system to save data persistently and to keep an history of the measurements even if the \textit{Control Unit} stops its execution.
		\begin{figure}[H]
			\centering{}
			\includegraphics{img/control-unit/db-scheme.png}
			\caption{Scheme of the database table}
			\label{img:control-unit/db-scheme}
		\end{figure}
		Since the system is interfaced to a database hosted in \textit{mySQL}, which by default runs in \textit{autocommit mode}, all transactions are guaranteed to be atomic, as if they were included in a commit sequence (\href{https://dev.mysql.com/doc/refman/8.4/en/commit.html}{\textit{as stated in this mySQL guide page}}). Therefore, the \textit{Control Unit} can delegate concurrency-related issues to the database Server.
		\subsection{Serial Agent}
		This component actively communicates with the \textit{Window Controller}. It's implemented in Java, relying on the \href{https://github.com/java-native/jssc}{\textit{JSSC library}} for Serial Line Communication. It's responsible of gathering the in-place control unit input, communicating it to the \textit{Central Controller} in order to reply effectively to the \textit{Window Controller} to actuate the - eventually - mutated state of the system.
		\subsection{MQTT Agent}
		This component actively communicates with the \textit{Temperature Monitor}. It's also implemented in Java, relying on the \href{https://vertx.io/}{\textit{VertX library}} to implement an event-based asynchronous component. Its main activity is to wait for the \textit{Temperature Monitor}'s messages, replying with the - eventually - mutated state of the system after communicating the measurements to the \textit{Central Controller} and retrieving the new state of the system.
		For \textit{MQTT} communication, I used a locally hosted instance of the \href{https://mosquitto.org/}{\textit{Mosquitto broker}}, with a custom configuration file to open a port for public connections. Then, I relied on the \href{https://github.com/ekzhang/bore}{\textit{Bore tunneling tool}} to effectively open the desired port for public connections, making it reachable also through a private network's firewall.
		\subsection{HTTP Server}
		This component communicates with the \textit{Operator Dashboard}, handling its \textit{HTTP requests} and forwarding demands to the \textit{Central Controller}. Like the \textit{MQTT Agent}, it's implemented in Java relying on the \href{https://vertx.io/}{\textit{VertX library}}, and also like the \textit{MQTT Agent} relies on the \href{https://github.com/ekzhang/bore}{\textit{Bore tunneling tool}} to publicly open the desired port, making it effectively reachable from outside the Server's private network.
		\subsection{Central Controller}
		This component is the actual core of the whole system. It's responsible of all accesses to the database, to which it delegates concurrency-related issues. It's implemented in Java, relying on the \href{https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/}{\textit{native JDBC API}} to connect to the database and query it for data management.
		
	\chapter{System Demonstration}
	\href{https://drive.google.com/file/d/1sJzZS7W2lpVfR6PkC-G01fWDvBJBSuEa/view?usp=drive_link}{\textit{At this link}} is available a video demonstration of the system.
	\newline The main issue in the deployment of the system was the complex wiring required by the sub-components, which was even more constraining because I only had one breadboard available. Furthermore, the complexity of the circuit relying solely on the \textit{Arduino UNO Board} powering source (since I couldn't supply the servo motor externally) resulted in some slight issues, visible towards the end of the video when I accidentally touched a cable, probably causing some disruption in the overall system tension that caused the LCD Screen to lose its clock and data sources and displaying unintelligible characters.
	
\end{document}